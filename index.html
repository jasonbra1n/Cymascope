<div style="text-align: center;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiThqa7DD48TlvvaTthPwkoWhVJQcapT9DgP4lh7zu2xoHFriMVHuL9HF-IWWPFzax8bqRjkdgQH3u4t3nrtUVIc_Hs7L6CiZ8HJJ3232ua1tGbFyM1rTJBQJ1wvpWxKt8H5EQ4rhuEjAv16qh4dYlLbDG7Z5u7HQ0UEa0iDmbaF3gwKnm61rm5nBXbcFH6/s1024/A-visually-striking-digital-artwork-of-a-circular-cymascope-in-action.-The-centerpiece-is-a-glowing-vibrant-circular-membrane-pulsating-with-intricat.webp" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1024" data-original-width="1024" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiThqa7DD48TlvvaTthPwkoWhVJQcapT9DgP4lh7zu2xoHFriMVHuL9HF-IWWPFzax8bqRjkdgQH3u4t3nrtUVIc_Hs7L6CiZ8HJJ3232ua1tGbFyM1rTJBQJ1wvpWxKt8H5EQ4rhuEjAv16qh4dYlLbDG7Z5u7HQ0UEa0iDmbaF3gwKnm61rm5nBXbcFH6/s320/A-visually-striking-digital-artwork-of-a-circular-cymascope-in-action.-The-centerpiece-is-a-glowing-vibrant-circular-membrane-pulsating-with-intricat.webp" width="320" /></a></div>

<style>

  /* Container to hold the canvas when not in fullscreen */
  #canvas-container {
    width: 100%;
    max-width: 100%;
    overflow: hidden;
    position: relative;
  }

  /* The canvas fills the container normally */
  #canvas-container canvas {
    border: 1px solid #444;
    background: black;
    width: 100%;
    height: 500px;
    display: block;
  }

  /* Controls styling */
  #controls {
    margin: 10px;
    padding: 10px;
    background: #333;
    border-radius: 5px;
  }
  /* Keep buttons and labels white */
  button, label {
    color: white;
    margin: 2px;
  }
  /* Make the select element text black */
  select {
    color: black;
    margin: 2px;
  }
  /* Ensure options within the select are black */
  select option {
    color: black;
  }
  .test-active {
    background: #4CAF50 !important;
  }
  /* When in fullscreen, override canvas styles to fill viewport */
  :-webkit-full-screen canvas,
  :fullscreen canvas {
    width: 100vw !important;
    height: 100vh !important;
  }
</style>

<div id="canvas-container">
  <canvas id="cymascope"></canvas>
</div>
<div id="controls">
  <button id="testButton">TEST VISUALIZATION</button>
  <label>Color Map:
    <select id="colorMap">
      <option value="rainbow">Rainbow</option>
      <option value="grayscale">Grayscale</option>
      <option value="heatmap">Heatmap</option>
    </select>
  </label>
  <label>Sensitivity:
    <input id="sensitivity" max="5" type="range" value="1" />
  </label>
  <button id="startStop">Start Audio</button>
  <button id="fullscreen">Full Screen</button>
</div>

<script>
  // Global variables
  let audioContext = null;
  let analyser = null;
  let mediaStreamSource = null;
  let isAudioInitialized = false;
  let gl = null;
  let program = null;
  let modeTextures = [];
  let smoothedWeights = null;
  let testMode = false;
  let testOscillator = null;
  const modes = [
    { n: 0, m: 1, k: 2.4048 }, { n: 0, m: 2, k: 5.5201 },
    { n: 0, m: 3, k: 8.6537 }, { n: 0, m: 4, k: 11.7915 },
    { n: 1, m: 1, k: 3.8317 }, { n: 1, m: 2, k: 7.0156 },
    { n: 1, m: 3, k: 10.1735 }, { n: 1, m: 4, k: 13.3237 },
    { n: 2, m: 1, k: 5.1356 }, { n: 2, m: 2, k: 8.4172 },
    { n: 2, m: 3, k: 11.6198 }, { n: 2, m: 4, k: 14.7960 },
    { n: 3, m: 1, k: 6.3802 }, { n: 3, m: 2, k: 9.7610 },
    { n: 3, m: 3, k: 13.0152 }, { n: 3, m: 4, k: 16.2235 }
  ];
  let effectiveModes = null;
  let effectiveModeCount = modes.length;
  let colorMapTextureUnit = null;

  // --- Shader sources ---
  const vertexShaderSource = `
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_uv = (a_position + 1.0) * 0.5;
    }
  `;
  function getFragmentShaderSource(modeCount) {
    return `#define MODE_COUNT ${modeCount}
    precision highp float;
    varying vec2 v_uv;
    uniform sampler2D modes[MODE_COUNT];
    uniform float weights[MODE_COUNT];
    uniform sampler2D colorMap;
    uniform float sensitivity;
    
    void main() {
        float sum = 0.0;
        for(int i = 0; i < MODE_COUNT; i++) {
            vec4 tex = texture2D(modes[i], v_uv);
            sum += weights[i] * (tex.r * 2.0 - 1.0);
        }
        float intensity = clamp(abs(sum) * sensitivity, 0.0, 1.0);
        vec3 color = texture2D(colorMap, vec2(intensity, 0.5)).rgb;
        gl_FragColor = vec4(color, 1.0);
    }
    `;
  }

  // --- WebGL initialization ---
  function initWebGL() {
    const canvas = document.getElementById('cymascope');
    // Set the internal size to match the container's displayed size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl = canvas.getContext('webgl', { antialias: false });
    if (!gl) {
        alert('WebGL not supported!');
        return;
    }
    // Update viewport to fill the canvas
    gl.viewport(0, 0, canvas.width, canvas.height);

    const maxUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    if (maxUnits < (modes.length + 1)) {
        effectiveModeCount = maxUnits - 1;
        console.warn(`Not enough texture units (${maxUnits}) available. Using ${effectiveModeCount} modes instead of ${modes.length}.`);
    }
    effectiveModes = modes.slice(0, effectiveModeCount);
    smoothedWeights = new Float32Array(effectiveModeCount).fill(0.5);
    colorMapTextureUnit = effectiveModeCount;
    const fragSrc = getFragmentShaderSource(effectiveModeCount);
    program = createProgram(gl, vertexShaderSource, fragSrc);
    if (!program) return;
    gl.useProgram(program);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1, 1, -1, -1, 1,
        1, -1, 1, 1, -1, 1
    ]), gl.STATIC_DRAW);
    const positionLoc = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
    modeTextures = effectiveModes.map((mode, i) => {
        const texture = createModeTexture(gl, mode.n, mode.k);
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(gl.getUniformLocation(program, `modes[${i}]`), i);
        return texture;
    });
    updateColorMap('rainbow');
    gl.uniform1f(gl.getUniformLocation(program, 'sensitivity'), 1.0);
    requestAnimationFrame(render);
  }

  // Adjust canvas size and viewport on window resize
  function resizeCanvas() {
    const canvas = document.getElementById('cymascope');
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    if (gl) {
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
  }
  window.addEventListener('resize', resizeCanvas);

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error((type === gl.VERTEX_SHADER ? "Vertex" : "Fragment") + " shader error:", gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
  }

  function createProgram(gl, vertexSrc, fragmentSrc) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
    if (!vertexShader || !fragmentShader) return null;
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program linking error:", gl.getProgramInfoLog(program));
        return null;
    }
    return program;
  }

  // --- Color Map Texture ---
  function createColorMapTexture(gl, type) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 1;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, 256, 0);
    if (type === 'rainbow') {
        gradient.addColorStop(0, '#FF0000');
        gradient.addColorStop(0.17, '#FFFF00');
        gradient.addColorStop(0.34, '#00FF00');
        gradient.addColorStop(0.51, '#00FFFF');
        gradient.addColorStop(0.68, '#0000FF');
        gradient.addColorStop(0.85, '#FF00FF');
        gradient.addColorStop(1, '#FF0000');
    } else if (type === 'grayscale') {
        gradient.addColorStop(0, 'black');
        gradient.addColorStop(1, 'white');
    } else {
        gradient.addColorStop(0, 'black');
        gradient.addColorStop(0.5, 'red');
        gradient.addColorStop(1, 'yellow');
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 256, 1);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    return texture;
  }

  function updateColorMap(type) {
    const colorMap = createColorMapTexture(gl, type);
    gl.activeTexture(gl.TEXTURE0 + colorMapTextureUnit);
    gl.bindTexture(gl.TEXTURE_2D, colorMap);
    gl.uniform1i(gl.getUniformLocation(program, 'colorMap'), colorMapTextureUnit);
  }

  // --- Math Helpers ---
  function factorial(n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
  }
  function besselJ(n, x) {
    let sum = 0;
    let term = Math.pow(x / 2, n) / factorial(n);
    sum += term;
    let k = 1;
    while (Math.abs(term) > 1e-10) {
        term *= -(x * x) / (4 * k * (n + k));
        sum += term;
        k++;
    }
    return sum;
  }

  // --- Create Mode Texture using Bessel functions ---
  function createModeTexture(gl, n, k, size = 256) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(size, size);
    const data = imageData.data;
    const center = size / 2;
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const dx = (x - center) / center;
            const dy = (y - center) / center;
            const r = Math.sqrt(dx * dx + dy * dy);
            if (r > 1) continue;
            const theta = Math.atan2(dy, dx);
            const u = besselJ(n, k * r) * Math.cos(n * theta);
            const value = (u + 1) / 2 * 255;
            const idx = (y * size + x) * 4;
            data[idx] = data[idx + 1] = data[idx + 2] = value;
            data[idx + 3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    return texture;
  }

  // --- Audio Initialization & Test Tone ---
  async function initAudio() {
    if (isAudioInitialized) return;
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        mediaStreamSource = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.8;
        mediaStreamSource.connect(analyser);
        isAudioInitialized = true;
    } catch (err) {
        alert('Microphone access required!');
    }
  }
  async function startStopAudio() {
    const button = document.getElementById('startStop');
    if (!isAudioInitialized) {
        await initAudio();
        button.textContent = 'Stop Audio';
    } else {
        audioContext.close();
        audioContext = null;
        analyser = null;
        mediaStreamSource = null;
        isAudioInitialized = false;
        button.textContent = 'Start Audio';
        smoothedWeights.fill(0);
    }
  }

  // --- Main Render Loop ---
  function render() {
    if (!gl) return;
    gl.clear(gl.COLOR_BUFFER_BIT);

    let frequencyData;
    if (testMode) {
        frequencyData = new Uint8Array(1024);
        const time = Date.now() / 1000;
        for(let i = 0; i < frequencyData.length; i++) {
            frequencyData[i] = Math.sin(i * 0.2 + time * 3) * 127 + 128;
        }
    } else if (isAudioInitialized && analyser) {
        frequencyData = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(frequencyData);
    }
    if (frequencyData) {
        const sampleRate = testMode ? 44100 : (audioContext?.sampleRate || 44100);
        const maxFrequency = sampleRate / 2;
        const weights = new Float32Array(effectiveModeCount);
        const alpha = 0.15;
        effectiveModes.forEach((mode, i) => {
          weights[i] = 0;
        });
        frequencyData.forEach((amp, i) => {
            const frequency = i * (maxFrequency / frequencyData.length);
            const modeIndex = effectiveModes.reduce((closestIdx, mode, idx) => {
                const currentDist = Math.abs(mode.k - (frequency / 100));
                const closestDist = Math.abs(effectiveModes[closestIdx].k - (frequency / 100));
                return currentDist < closestDist ? idx : closestIdx;
            }, 0);
            weights[modeIndex] += amp / 255;
        });
        weights.forEach((w, i) => {
            smoothedWeights[i] = alpha * w + (1 - alpha) * smoothedWeights[i];
        });
        gl.uniform1fv(gl.getUniformLocation(program, 'weights'), smoothedWeights);
    }
    const sensitivity = parseFloat(document.getElementById('sensitivity').value);
    gl.uniform1f(gl.getUniformLocation(program, 'sensitivity'), sensitivity);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }

  // --- UI Event Listeners ---
  document.getElementById('fullscreen').addEventListener('click', () => {
    const canvas = document.getElementById('cymascope');
    if (!document.fullscreenElement) {
        canvas.requestFullscreen().catch(console.error);
    } else {
        document.exitFullscreen();
    }
  });
  document.getElementById('colorMap').addEventListener('change', (e) => {
    updateColorMap(e.target.value);
  });
  document.getElementById('startStop').addEventListener('click', startStopAudio);
  document.getElementById('sensitivity').addEventListener('input', () => {
    if (program) {
        const sensitivity = parseFloat(document.getElementById('sensitivity').value);
        gl.uniform1f(gl.getUniformLocation(program, 'sensitivity'), sensitivity);
    }
  });
  document.getElementById('testButton').addEventListener('click', () => {
    testMode = !testMode;
    const button = document.getElementById('testButton');
    button.classList.toggle('test-active');
    button.textContent = testMode ? 'STOP TEST' : 'TEST VISUALIZATION';
    
    if (testMode) {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (!testOscillator) {
            testOscillator = audioContext.createOscillator();
            testOscillator.type = 'sine';
            testOscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            testOscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            testOscillator.start();
        }
    } else {
        if (testOscillator) {
            testOscillator.stop();
            testOscillator.disconnect();
            testOscillator = null;
        }
    }
  });

  // --- Start WebGL ---
  initWebGL();
</script>
